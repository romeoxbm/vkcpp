// Copyright(c) 2015-2016, NVIDIA CORPORATION. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#ifndef STRINGS
#define STRINGS

namespace vk
{
	const std::string nvidiaLicenseHeader(
		"// Copyright(c) 2015-2016, NVIDIA CORPORATION. All rights reserved.\n"
		"//\n"
		"// Redistribution and use in source and binary forms, with or without\n"
		"// modification, are permitted provided that the following conditions\n"
		"// are met:\n"
		"//  * Redistributions of source code must retain the above copyright\n"
		"//    notice, this list of conditions and the following disclaimer.\n"
		"//  * Redistributions in binary form must reproduce the above copyright\n"
		"//    notice, this list of conditions and the following disclaimer in the\n"
		"//    documentation and/or other materials provided with the distribution.\n"
		"//  * Neither the name of NVIDIA CORPORATION nor the names of its\n"
		"//    contributors may be used to endorse or promote products derived\n"
		"//    from this software without specific prior written permission.\n"
		"//\n"
		"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n"
		"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n"
		"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n"
		"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n"
		"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n"
		"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n"
		"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n"
		"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n"
		"// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
		"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
		"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
	);

	const std::string exceptionHeader(
		"#if defined( _MSC_VER ) && ( _MSC_VER == 1800 )\n"
		"# define noexcept _NOEXCEPT\n"
		"#endif\n"
		"\n"
		"  class ErrorCategoryImpl : public std::error_category\n"
		"  {\n"
		"    public:\n"
		"    virtual const char* name() const noexcept override { return \"vk::Result\"; }\n"
		"    virtual std::string message( int ev ) const override { return to_string( static_cast<Result>( ev ) ); }\n"
		"  };\n"
		"\n"
		"#if defined( _MSC_VER ) && ( _MSC_VER == 1800 )\n"
		"# undef noexcept\n"
		"#endif\n"
		"\n"
		"  inline const std::error_category& errorCategory()\n"
		"  {\n"
		"    static ErrorCategoryImpl instance;\n"
		"    return instance;\n"
		"  }\n"
		"\n"
		"  inline std::error_code make_error_code( Result e )\n"
		"  {\n"
		"    return std::error_code( static_cast<int>( e ), errorCategory() );\n"
		"  }\n"
		"\n"
		"  inline std::error_condition make_error_condition( Result e )\n"
		"  {\n"
		"    return std::error_condition( static_cast<int>( e ), errorCategory() );\n"
		"  }\n"
		"\n"
	);

	const std::string flagsHeader(
		"  template<typename BitType, typename MaskType = uint32_t>\n"
		"  class Flags\n"
		"  {\n"
		"  public:\n"
		"    Flags()\n"
		"      : m_mask( 0 )\n"
		"    {}\n"
		"\n"
		"    Flags( BitType bit )\n"
		"      : m_mask( static_cast<uint32_t>( bit ) )\n"
		"    {}\n"
		"\n"
		"    Flags( Flags<BitType> const& rhs )\n"
		"      : m_mask( rhs.m_mask )\n"
		"    {}\n"
		"\n"
		"    Flags<BitType>& operator=( Flags<BitType> const& rhs )\n"
		"    {\n"
		"      m_mask = rhs.m_mask;\n"
		"      return *this;\n"
		"    }\n"
		"\n"
		"    Flags<BitType>& operator|=( Flags<BitType> const& rhs )\n"
		"    {\n"
		"      m_mask |= rhs.m_mask;\n"
		"      return *this;\n"
		"    }\n"
		"\n"
		"    Flags<BitType>& operator&=( Flags<BitType> const& rhs )\n"
		"    {\n"
		"      m_mask &= rhs.m_mask;\n"
		"      return *this;\n"
		"    }\n"
		"\n"
		"    Flags<BitType>& operator^=( Flags<BitType> const& rhs )\n"
		"    {\n"
		"      m_mask ^= rhs.m_mask;\n"
		"      return *this;\n"
		"    }\n"
		"\n"
		"    Flags<BitType> operator|( Flags<BitType> const& rhs ) const\n"
		"    {\n"
		"      Flags<BitType> result(*this);\n"
		"      result |= rhs;\n"
		"      return result;\n"
		"    }\n"
		"\n"
		"    Flags<BitType> operator&( Flags<BitType> const& rhs ) const\n"
		"    {\n"
		"      Flags<BitType> result( *this );\n"
		"      result &= rhs;\n"
		"      return result;\n"
		"    }\n"
		"\n"
		"    Flags<BitType> operator^( Flags<BitType> const& rhs ) const\n"
		"    {\n"
		"      Flags<BitType> result( *this );\n"
		"      result ^= rhs;\n"
		"      return result;\n"
		"    }\n"
		"\n"
		"    bool operator!() const\n"
		"    {\n"
		"      return !m_mask;\n"
		"    }\n"
		"\n"
		"    bool operator==( Flags<BitType> const& rhs ) const\n"
		"    {\n"
		"      return m_mask == rhs.m_mask;\n"
		"    }\n"
		"\n"
		"    bool operator!=( Flags<BitType> const& rhs ) const\n"
		"    {\n"
		"      return m_mask != rhs.m_mask;\n"
		"    }\n"
		"\n"
		"    explicit operator bool() const\n"
		"    {\n"
		"      return !!m_mask;\n"
		"    }\n"
		"\n"
		"    explicit operator MaskType() const\n"
		"    {\n"
		"        return m_mask;\n"
		"    }\n"
		"\n"
		"  private:\n"
		"    MaskType  m_mask;\n"
		"  };\n"
		"  \n"
		"  template<typename BitType>\n"
		"  Flags<BitType> operator|( BitType bit, Flags<BitType> const& flags )\n"
		"  {\n"
		"    return flags | bit;\n"
		"  }\n"
		"  \n"
		"  template<typename BitType>\n"
		"  Flags<BitType> operator&( BitType bit, Flags<BitType> const& flags )\n"
		"  {\n"
		"    return flags & bit;\n"
		"  }\n"
		"  \n"
		"  template<typename BitType>\n"
		"  Flags<BitType> operator^( BitType bit, Flags<BitType> const& flags )\n"
		"  {\n"
		"    return flags ^ bit;\n"
		"  }\n"
		"\n"
	);

	std::string const optionalClassHeader = (
		"  template<typename RefType>\n"
		"  class Optional\n"
		"  {\n"
		"  public:\n"
		"    Optional( RefType& reference ) { m_ptr = &reference; }\n"
		"    Optional( std::nullptr_t ) { m_ptr = nullptr; }\n"
		"\n"
		"    operator RefType*() const { return m_ptr; }\n"
		"    RefType const* operator->() const { return m_ptr; }\n"
		"    explicit operator bool() const { return !!m_ptr; }\n"
		"\n"
		"  private:\n"
		"    RefType* m_ptr;\n"
		"  };\n"
		"\n"
	);

	std::string const arrayProxyHeader = (
		"  template<typename T>\n"
		"  class ArrayProxy\n"
		"  {\n"
		"  public:\n"
		"    ArrayProxy( std::nullptr_t )\n"
		"      : m_count( 0 )\n"
		"      , m_ptr( nullptr )\n"
		"    {}\n"
		"\n"
		"    ArrayProxy( T& ptr )\n"
		"      : m_count( 1 )\n"
		"      , m_ptr( &ptr )\n"
		"    {}\n"
		"\n"
		"    ArrayProxy( uint32_t count, T* ptr )\n"
		"      : m_count( count )\n"
		"      , m_ptr( ptr )\n"
		"    {}\n"
		"\n"
		"    template<size_t N>\n"
		"    ArrayProxy( std::array<typename std::remove_const<T>::type, N>& data )\n"
		"      : m_count( N )\n"
		"      , m_ptr( data.data() )\n"
		"    {}\n"
		"\n"
		"    template<size_t N>\n"
		"    ArrayProxy( std::array<typename std::remove_const<T>::type, N> const& data )\n"
		"      : m_count( N )\n"
		"      , m_ptr( data.data() )\n"
		"    {}\n"
		"\n"
		"    template<class Allocator = std::allocator<typename std::remove_const<T>::type>>\n"
		"    ArrayProxy( std::vector<typename std::remove_const<T>::type, Allocator>& data )\n"
		"      : m_count( static_cast<uint32_t>( data.size() ) )\n"
		"      , m_ptr( data.data() )\n"
		"    {}\n"
		"\n"
		"    template<class Allocator = std::allocator<typename std::remove_const<T>::type>>\n"
		"    ArrayProxy( std::vector<typename std::remove_const<T>::type, Allocator> const& data )\n"
		"      : m_count( static_cast<uint32_t>( data.size() ) )\n"
		"      , m_ptr( data.data() )\n"
		"    {}\n"
		"\n"
		"    ArrayProxy( std::initializer_list<T> const& data )\n"
		"      : m_count( static_cast<uint32_t>( data.end() - data.begin() ) )\n"
		"      , m_ptr( data.begin() )\n"
		"    {}\n"
		"\n"
		"    uint32_t size() const\n"
		"    {\n"
		"      return m_count;\n"
		"    }\n"
		"\n"
		"    T* data() const\n"
		"    {\n"
		"      return m_ptr;\n"
		"    }\n"
		"\n"
		"  private:\n"
		"    uint32_t  m_count;\n"
		"    T*        m_ptr;\n"
		"  };\n"
		"\n"
	);

	std::string const versionCheckHeader = (
		"#ifndef VK_CPP_HAS_UNRESTRICTED_UNIONS\n"
		"# ifdef __clang__\n"
		"#  if __has_feature( cxx_unrestricted_unions )\n"
		"#   define VK_CPP_HAS_UNRESTRICTED_UNIONS\n"
		"#  endif\n"
		"# elif defined( __GNUC__ )\n"
		"#  define GCC_VERSION ( __GNUC__ * 1000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__ )\n"
		"#  if 40600 <= GCC_VERSION\n"
		"#   define VK_CPP_HAS_UNRESTRICTED_UNIONS\n"
		"#  endif\n"
		"# elif defined( _MSC_VER )\n"
		"#  if 1900 <= _MSC_VER\n"
		"#   define VK_CPP_HAS_UNRESTRICTED_UNIONS\n"
		"#  endif\n"
		"# endif\n"
		"#endif\n\n"
	);

	std::string const resultValueHeader = (
		"  template<typename T>\n"
		"  struct ResultValue\n"
		"  {\n"
		"    ResultValue( Result r, T& v )\n"
		"      : result( r )\n"
		"      , value( v )\n"
		"    {}\n"
		"\n"
		"    Result  result;\n"
		"    T       value;\n"
		"  };\n"
		"\n"
		"  template<typename T>\n"
		"  struct ResultValueType\n"
		"  {\n"
		"#ifdef VK_CPP_NO_EXCEPTIONS\n"
		"    typedef ResultValue<T>  type;\n"
		"#else\n"
		"    typedef T              type;\n"
		"#endif\n"
		"  };\n"
		"\n"
		"  template<>\n"
		"  struct ResultValueType<void>\n"
		"  {\n"
		"#ifdef VK_CPP_NO_EXCEPTIONS\n"
		"    typedef Result type;\n"
		"#else\n"
		"    typedef void   type;\n"
		"#endif\n"
		"  };\n"
		"\n"
	);

	std::string const createResultValueHeader = (
		"  inline ResultValueType<void>::type createResultValue( Result result, char const* message )\n"
		"  {\n"
		"#ifdef VK_CPP_NO_EXCEPTIONS\n"
		"    assert( result == Result::eSuccess );\n"
		"    return result;\n"
		"#else\n"
		"    if ( result != Result::eSuccess )\n"
		"    {\n"
		"      throw std::system_error( result, message );\n"
		"    }\n"
		"#endif\n"
		"  }\n"
		"\n"
		"  template<typename T>\n"
		"  inline typename ResultValueType<T>::type createResultValue( Result result, T& data, char const* message )\n"
		"  {\n"
		"#ifdef VK_CPP_NO_EXCEPTIONS\n"
		"    assert( result == Result::eSuccess );\n"
		"    return ResultValue<T>( result, data );\n"
		"#else\n"
		"    if ( result != Result::eSuccess )\n"
		"    {\n"
		"      throw std::system_error( result, message );\n"
		"    }\n"
		"    return data;\n"
		"#endif\n"
		"  }\n"
		"\n"
		"  inline Result createResultValue( Result result, char const* message, std::initializer_list<Result> successCodes )\n"
		"  {\n"
		"#ifdef VK_CPP_NO_EXCEPTIONS\n"
		"    assert( std::find( successCodes.begin(), successCodes.end(), result ) != successCodes.end() );\n"
		"#else\n"
		"    if ( std::find( successCodes.begin(), successCodes.end(), result ) == successCodes.end() )\n"
		"    {\n"
		"      throw std::system_error( result, message );\n"
		"    }\n"
		"#endif\n"
		"    return result;\n"
		"  }\n"
		"\n"
		"  template<typename T>\n"
		"  inline ResultValue<T> createResultValue( Result result, T& data, char const* message, std::initializer_list<Result> successCodes )\n"
		"  {\n"
		"#ifdef VK_CPP_NO_EXCEPTIONS\n"
		"    assert( std::find( successCodes.begin(), successCodes.end(), result ) != successCodes.end() );\n"
		"#else\n"
		"    if ( std::find( successCodes.begin(), successCodes.end(), result ) == successCodes.end() )\n"
		"    {\n"
		"      throw std::system_error( result, message );\n"
		"    }\n"
		"#endif\n"
		"    return ResultValue<T>( result, data );\n"
		"  }\n"
		"\n"
	);

	std::string const isErrorCode = (
		"namespace std\n"
		"{\n"
		"  template<>\n"
		"  struct is_error_code_enum<vk::Result> : public true_type\n"
		"  {};\n"
		"}\n"
	);
}

#endif // STRINGS
